#+TITLE:       Tensor Flow - Simple graph
#+AUTHOR:      Arturo Vivas
#+EMAIL:       arturo.vivas@gmail.com
#+DATE:        2016-11-27 So
#+URI:         /blog/%y/%m/%d/Tensor-flow-001
#+KEYWORDS:    tensor flow, linear algebra
#+TAGS:        tensor flow
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: Introduction to Tensor Flow

The first very very very small program using TensorFlow. In the following lines we are going to perform a sum of two scalars. This may sound trivial, yet the important concept in the following code is the "graph" behind it.

#+NAME: tensorflow
#+BEGIN_SRC ipython :session mysession :exports both
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt

session = tf.Session()

a = tf.constant(10, name="input_a")
b = tf.constant(20, name="input_b")
c = tf.add(a, b, name="add_c")

result = session.run(c)
(result)
#+END_SRC

#+RESULTS: tensorflow
: 30


Here comes the interessting part, also pass auf! The small calculation Tensorflow  just did is the result of the computation of the *computational graph* defined in the code. The graphical visualization of the code would be the following:


#+BEGIN_SRC dot :export none  :file ./img/s1.png :cmdline -Kdot -Tpng  :results output silent
digraph G {

          rankdir=LR
	  splines=line
          nodesep=.05;
          x2 [label="10"];
          x1 [label="20"];
          a12 [label="10+20"];

          subgraph cluster_0 {
		  color=white;
                  node [style=solid,color=blue4, shape=circle];
		  x1 x2 ;
		  label = "layer 1 = Inputs";
	  }

	  subgraph cluster_1 {
		  color=white;
		  node [style=solid,color=red2, shape=circle];
		  a12 ;
		  label = "layer 2 = Output";
	  }

        x1 -> a12;
        x2 -> a12;

}
#+END_SRC


#+CAPTION: Our Program's graph
[[file:./img/s1.png]]

This was a very simple example yet, it shows TensorFlow's main functionality. *Tensors which flow along the computational Graph*. Let's see another example, this time with a bigger graph.

#+BEGIN_SRC dot :export none  :file ./img/s2.png :cmdline -Kdot -Tpng  :results output silent
  digraph G {

              rankdir=LR
	      splines=line
              nodesep=.05;
              x1 [label="x1"];
              x2 [label="x2"];

              a12 [label="h11"];
              a22 [label="h11"];
   
              a13 [label="h12"];
              a23 [label="h22"];
  
              a14 [label="o1"];
              a24 [label="o2"];


              subgraph cluster_0 {
		      color=white;
                      node [style=solid,color=blue4, shape=circle];
		      x1 x2;
		      label = "layer 1 = Inputs";
	      }

	      subgraph cluster_1 {
		      color=white;
		      node [style=solid,color=red2, shape=circle];
		      a12 a22;
		      label = "layer 2 = Hidden Layer (sum)";
	      }

              subgraph cluster_3 {
		      color=white;
		      node [style=solid,color=red2, shape=circle];
		      a13 a23;
		      label = "layer 3 = Hidden Layer (power)";
	      }

             subgraph cluster_4 {
		      color=white;
		      node [style=solid,color=red2, shape=circle];
		      a14 a24;
		      label = "layer 3 = Output Layer (divide)";
	      }

            x1 -> a12;
            x1 -> a22;

            x2 -> a12;
            x2 -> a22;
             
            a12 -> a13;
            a12 -> a23;

            a22 -> a13;  
            a22 -> a23;            

            a13 -> a14;
            a13 -> a24;

            a23 -> a14;
            a23 -> a24; 
    }

#+END_SRC

#+CAPTION: A graph with four layers and 12 connections
[[file:./img/s2.png]]

The TF-Code to this graph is the following:

#+BEGIN_SRC ipython :session mysession :export both
# Let's create a new tensorflow sesion
tfs2 =tf.Session()

# Let's create each one of our input variables assigning them a value 
x1=tf.constant(23, name="x1")
x2=tf.constant(34, name="x2")

# Let's define the interactions of the first layer with the second one
h11=tf.add(x1,x2, name="h11")
h21=tf.add(x1,x2, name="h21")

# The interacions between the second layer and the third
h12= tf.pow(h11, h21, name="h11")
h22= tf.pow(h11, h21, name="h21")

# Let's define the outputlayer 
o1=tf.div(h12,h22, name="o1")
o2=tf.div(h12,h22, name="o2")

# With the next command TF will evaluate the node "o5"
tfs2.run(o1)
#+END_SRC

#+RESULTS:
: 1
